<!DOCTYPE html>
<meta charset="utf-8">
<style>
body {
	font-family: sans-serif;
	font-size: 8pt;
	color: grey;
}
.node {
	stroke: #fff;
	stroke-width: 1.5px;
}

.link {
	stroke: #999;
	stroke-opacity: .6;
}

</style>
<body>
<!--script src="http://d3js.org/d3.v3.min.js"></script-->
<script src="d3.v3.min.js"></script>
<script>
xmlDoc=loadConfigDocument();
nodes = []
links = []
sizes = {}
nodeIndexes = {}
var pipelineGroups=xmlDoc.getElementsByTagName("pipelines")
for(groupIndex=0; groupIndex < pipelineGroups.length; groupIndex++) {
	var pipelineGroup = pipelineGroups[groupIndex]
	var pipelines=pipelineGroup.getElementsByTagName('pipeline')
	for(pipelineIndex=0; pipelineIndex < pipelines.length; pipelineIndex++) {
		var pipeline = pipelines[pipelineIndex]
		var pipelineName=pipeline.getAttribute('name')
		if (pipelineName) {
			foundNode(pipelineName, pipelineGroup.getAttribute('group'), 'circle')
			if (pipeline.getAttribute('template')) {
				foundNode(pipeline.getAttribute('template'), 'templates', 'square')
				links.push([pipelineName, pipeline.getAttribute('template')])
				sizes[pipeline.getAttribute('template')]++
			}
			if (pipeline.getElementsByTagName('materials')[0]) {
				var materials=pipeline.getElementsByTagName('materials')[0].children
				for (materialIndex=0; materialIndex < materials.length; materialIndex++) {
					var material=materials[materialIndex]
					var materialName
					if (material.tagName==='pipeline') {
						materialName=material.getAttribute('pipelineName')
					}
					else {
						materialName = material.getAttribute('url')
						if (! nodes[materialName]) {
							foundNode(materialName, material.tagName, 'triangle-up')
						}
					}
					links.push([pipelineName, materialName])
					sizes[materialName]++
				}
			}
		}
	}
}
var templates=xmlDoc.getElementsByTagName("templates")[0].getElementsByTagName("pipeline")
for(templateIndex=0; templateIndex < templates.length; templateIndex++) {
	foundNode(templates[templateIndex].getAttribute('name'), 'templates', 'square')
}
var graph = {'nodes': [], 'links': []}

for (nodeIndex=0;nodeIndex<nodes.length;nodeIndex++) {
	var node=nodes[nodeIndex]
	graph.nodes.push({'name': node.name, 'group': node.group, 'shape': node.shape, 'size': sizes[node.name]})
}
for (linkIndex=0;linkIndex<links.length;linkIndex++) {
	var sourceName=links[linkIndex][0], targetName=links[linkIndex][1]
	graph.links.push({'source': nodeIndexes[sourceName], 'target': nodeIndexes[targetName]})
}

function loadConfigDocument() {
	if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari
		xmlHttp=new XMLHttpRequest();
	}
	else { // code for IE6, IE5
		xmlHttp=new ActiveXObject("Microsoft.XMLHTTP");
	}

	configUrl=getParameterByName("configUrl") || "sample.xml";
	xmlHttp.open("GET", configUrl, false)
	xmlHttp.withCredentials = "true"; 
	xmlHttp.send();
	return xmlHttp.responseXML;
}
function foundNode(name, group, shape) {
	if (! nodeIndexes[name]) {
		nodeIndexes[name]=nodes.length
		nodes.push({'name': name, 'group': group, 'shape': shape})
		sizes[name]=0
	}
}
function getParameterByName(name, url) {
	var url = typeof url !== 'undefined' ? url : window.location.href
	name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
	var regexS = "[\\?&]" + name + "=([^&#]*)";
	var regex = new RegExp(regexS);
	var results = regex.exec(url);
	if(results == null)
		return "";
	else
		return decodeURIComponent(results[1].replace(/\+/g, " "));
}
var width = window.innerWidth,
	height = window.innerHeight,
	radius = 70,
	color = d3.scale.category20();

var force = d3.layout.force()
		.charge(-300)
		.linkDistance(100)
		.size([width, height]);

var svg = d3.select("body").append("svg")
		.attr("width", width)
		.attr("height", height);

var drawGraph = function(graph) {
	force
		.nodes(graph.nodes)
		.links(graph.links)
		.start();

	svg.append("svg:defs").selectAll("marker")
		.data(["arrow"])
		.enter()
		.append("marker")
			.attr("id", function(d) { return d; })
			.attr("viewBox", "0 -5 10 10")
			.attr("refX", 10)
			.attr("refY", 0)
			.attr("markerWidth", 10)
			.attr("markerHeight", 10)
			.attr("orient", "auto")
		.append("path")
			.style("stroke", function(d) { return "grey"; })
			.style("fill", function(d) { return "grey"; })
			.attr("d", "M0,-5L10,0L0,5");

	var links = svg.selectAll(".link")
		.data(graph.links)
		.enter()
			.append("svg:path")
			.style("fill", function(d) { return "none"; })
			.style("stroke", function(d) { return "grey"; })
			.attr("marker-end", function(d) { return "url(#arrow)"; });

	var gnodes = svg.selectAll('g.gnode')
		 .data(graph.nodes)
		 .enter()
		 .append('g')
		 .classed('gnode', true);
 
	var node = gnodes.append("path")
		.attr("d", d3.svg.symbol()
			.size(function(d) { return radius+d.size*radius; })
			.type(function(d) { return d.shape; })
		)
		.style("fill", function(d) { return color(d.group); })
		.style("stroke", function(d) { return d3.rgb(color(d.group)).darker(); })
		.call(force.drag);

	var labels = gnodes.append("text")
		.text(function(d) { return d.name; })
		.attr("x", function(d) { return 10 + d.size; })
		.attr("y", "3")
		.attr("font-family", "sans-serif")
		.attr("font-size","7pt")
		.attr("fill", function(d) { return d3.rgb(color(d.group)).darker(); });

	force.on("tick", function() {
		links.attr('d', linkRespectingRadius);
		gnodes.attr("transform", function(d) { 
				return 'translate(' + [d.x, d.y] + ')';
		});
	});
};

function linkRespectingRadius(d) {
	// Total difference in x and y from source to target
	diffX = d.target.x - d.source.x;
	diffY = d.target.y - d.source.y;

	// Length of path from center of source node to center of target node
	pathLength = Math.sqrt((diffX * diffX) + (diffY * diffY));
	radiusOfTarget=d.target.size+7
	// x and y distances from center to outside edge of target node
	offsetX = (diffX * radiusOfTarget) / pathLength;
	offsetY = (diffY * radiusOfTarget) / pathLength;

	return "M" + d.source.x + "," + d.source.y + "L" + (d.target.x - offsetX) + "," + (d.target.y - offsetY);
}

drawGraph(graph);

</script>
<p>Legend: Triangles are source code repositories, circles are pipelines, squares are pipeline templates. Lines indicate dependencies.</p>
<p>Developed from <a href="http://bl.ocks.org/mbostock">Mike Bostock's Force Directed Graph examples</a></p>