<!DOCTYPE html>
<meta charset="utf-8">
<style>
body {
	font-family: sans-serif;
	font-size: 8pt;
	color: grey;
}
.node {
	stroke: #fff;
	stroke-width: 1.5px;
}

.link {
	stroke: #999;
	stroke-opacity: .6;
}

#graph-link-placeholder {
	position: absolute;
	right: 0;
	width: 10em;
	text-align: right;
	background-color: white;
}

</style>
<body>
<div id="graph-link-placeholder">Hello</div>
<script src='jszip.min.js'></script>
<!--script src="http://d3js.org/d3.v3.min.js"></script-->
<script src="d3.v3.min.js"></script>
<script>
nodes = {}
links = [] // change this to use node indexes
// Then we shouldn't need to create do another pass on the nodes later to generate the links
// Get rid of the extra node collections as we won't need them
// Make sure everything is indexed on node number
// Then perhaps try not storing the node names?
typedLinks = []
sizes = {}
nodeIndexes = {}
nodesFound = 0
pipelineIndexes = {}
pipelines = {}
groups = []
repos = []
repoTypes = {}
pipelineTemplates = []
xmlDoc=loadConfigDocument();
var pipelineGroups=xmlDoc.getElementsByTagName("pipelines")
var templates=xmlDoc.getElementsByTagName("templates")[0].getElementsByTagName("pipeline")

buildGraph(pipelineGroups, templates)
function buildGraph (pipelineGroups, templates) {

	for(templateIndex=0; templateIndex < templates.length; templateIndex++) {
		foundTemplate(templates[templateIndex].getAttribute('name'), nodes)
	}
	for(groupIndex=0; groupIndex < pipelineGroups.length; groupIndex++) {
		var pipelineGroup = pipelineGroups[groupIndex]
		var groupNodeIndex = foundGroup(pipelineGroup.getAttribute('group'))
		var pipelines=pipelineGroup.getElementsByTagName('pipeline')
		for(var pipelineIndex=0; pipelineIndex < pipelines.length; pipelineIndex++) {

			var pipeline = pipelines[pipelineIndex]
			var pipelineName=pipeline.getAttribute('name')
			if (pipelineName) {
				var pipelineNodeIndex = foundPipeline(pipelineName, pipelineGroup.getAttribute('group'), nodes)
				if (pipeline.getAttribute('template')) {
					var templateNodeIndex = foundTemplate(pipeline.getAttribute('template'), nodes)
					typedLinks.push({source: pipelineName, targetType: 'template', targetName: pipeline.getAttribute('template')})
					links.push([pipelineName, pipeline.getAttribute('template')])
					sizes[templateNodeIndex]++
				}
				if (pipeline.getElementsByTagName('materials')[0]) {
					var materials=pipeline.getElementsByTagName('materials')[0].children
					for (materialIndex=0; materialIndex < materials.length; materialIndex++) {
						var material=materials[materialIndex]
						var materialName
						var materialNodeIndex = -1
						if (material.tagName==='pipeline') {
							materialName=material.getAttribute('pipelineName')
							materialNodeIndex = foundPipeline(material.getAttribute('pipelineName'), pipelineGroup.getAttribute('group'), nodes)
							typedLinks.push({source: pipelineName, targetType: 'pipeline', targetName: material.getAttribute('pipelineName')})
						}
						else if (material.tagName==='package') {
							// do something here
						}
						else {
							materialName = material.getAttribute('url')
							materialNodeIndex = foundRepo(materialName, material.tagName, nodes)
							typedLinks.push({source: pipelineName, targetType: 'repo', targetName: materialName})
						}
						links.push([pipelineName, materialName])
						sizes[materialNodeIndex]++
					}
				}
			}
		}
	}
}
function foundGroup (pipelineGroup) {
	groups.push(pipelineGroup)
	pipelines[groups.indexOf(pipelineGroup)]=[]
}
function foundPipeline(pipelineName, pipelineGroup, nodes) {
	if (groups.indexOf(pipelineGroup) < 0) groups.push(pipelineGroup)
	if (!pipelineIndexes[pipelineName]) {
		pipelines[groups.indexOf(pipelineGroup)].push(pipelineName)
		pipelineIndexes[pipelineName]=pipelineIndexes.length
		groups[pipelineName]=pipelineGroup
	}
	return foundNode(pipelineName, pipelineGroup, 'circle', nodes)
}
function foundRepo(repoUrl, repoType, nodes) {
	if (repos.indexOf(repoUrl) < 0) {
		repos.push(repoUrl)
		repoTypes[repoUrl]=repoType
	}
	return foundNode(repoUrl, repoType, 'triangle-up', nodes)
}
function foundTemplate(templateName, nodes) {
	if (pipelineTemplates.indexOf(templateName) < 0) pipelineTemplates.push(templateName)
	return foundNode(templateName, 'templates', 'triangle-up', nodes)
}

linkIndices={}
for (linkIndex=0;linkIndex<typedLinks.length;linkIndex++) {
	link=typedLinks[linkIndex]
	sourceIndex=parseInt(pipelineIndexes[link.source])
	if (!linkIndices[sourceIndex]) {linkIndices[sourceIndex]=[]}
	if (link.targetType==='pipeline') {
		linkIndices[sourceIndex].push(parseInt(pipelineIndexes[link.targetName]))
	}	
	else if (link.targetType==='repo') {
		linkIndices[sourceIndex].push(pipelineIndexes.length+parseInt(repos.indexOf(link.targetName)))
	}
	else if (link.targetType==='template') {
		linkIndices[sourceIndex].push(pipelineIndexes.length+repos.length+parseInt(pipelineTemplates.indexOf(link.targetName)))
	}
	else { console.error('unrecognised link type') }
}
dependencies={p:pipelines, r: repos, t: pipelineTemplates, l: linkIndices}
////console.log("dependencies:\n" + encodeURIComponent(graph))
//console.log("plain  length: " + JSON.stringify(dependencies))
// compressed = new JSZip().file('dependencies', JSON.stringify(dependencies)).generate({type:"base64", compression:"deflate"})
// console.log("compressed: "+compressed.length)
// decompressed = new JSZip().load(compressed, {base64: true, compression:"deflate"}).file('dependencies').asText();
// console.log("decompressed length " + decompressed.length)

var sizesFromDependencies = {}

for (linkIndex=0;linkIndex<dependencies.l.length;linkIndex++) {
	var linkTargets=dependencies.l[linkIndex]
	for (targetIndex=0; targetIndex<linkTargets.length; targetIndex++) {
		target=linkTargets[targetIndex]
		if (sizesFromDependencies.indexOf(target) < 0) sizesFromDependencies[target]=0
		sizesFromDependencies[target]++
	}
}



var graph = {'nodes': [], 'links': []}

// 
// for (pipelineIndex=0;pipelineIndex<dependencies.p.length;pipelineIndex++) {
// 	var pipeline=dependencies.p[pipelineIndex]
// 	graph.nodes.push({'name': pipeline.name, 'group': pipeline.group, 'shape': 'circle', 'size': sizesFromDependencies[pipelineIndex]})
// }
// for (repoIndex=0;repoIndex<dependencies.r.length;repoIndex++) {
// 	var repo=dependencies.r[repoIndex]
// 	graph.nodes.push({'name': repo.name, 'group': pipeline.group, 'shape': 'circle', 'size': sizesFromDependencies[pipelineIndex]})
// }

console.log(sizes)
for (nodeIndex=0;nodeIndex<nodesFound;nodeIndex++) {
	var node=nodes[nodeIndex]
	console.log("node is " + node)
	graph.nodes.push({'name': node.name, 'group': node.group, 'shape': node.shape, 'size': sizes[nodeIndex]})
}
for (linkIndex=0;linkIndex<links.length;linkIndex++) {
	var sourceName=links[linkIndex][0], targetName=links[linkIndex][1]
	graph.links.push({'source': nodeIndexes[sourceName], 'target': nodeIndexes[targetName]})
}

document.getElementById('graph-link-placeholder').innerHTML = '<a href="?dependencies='+encodeURIComponent(JSON.stringify(graph))+'">share link</a>';
function loadConfigDocument() {
	SYNCHRONOUS=false
	if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari
		xmlHttp=new XMLHttpRequest();
	}
	else { // code for IE6, IE5
		xmlHttp=new ActiveXObject("Microsoft.XMLHTTP");
	}

	configUrl=getParameterByName("configUrl") || "sample.xml";
	xmlHttp.open("GET", configUrl, SYNCHRONOUS)
	xmlHttp.withCredentials = "true"; // Tells the browser to send authentication cookies.
	xmlHttp.send();
	return xmlHttp.responseXML;
}
function foundNode(name, group, shape, nodes) {
	var nodeIndex = nodeIndexes[name]
	if (! nodeIndex) {
		nodeIndex=nodesFound ++
		nodeIndexes[name]=nodeIndex
		nodes[nodeIndex] = {'name': name, 'group': group, 'shape': shape}
		sizes[nodeIndex]=0
	}
	return nodeIndex;
}
function getParameterByName(name, url) {
	var url = typeof url !== 'undefined' ? url : window.location.href
	name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
	var regexS = "[\\?&]" + name + "=([^&#]*)";
	var regex = new RegExp(regexS);
	var results = regex.exec(url);
	if(results == null)
		return "";
	else
		return decodeURIComponent(results[1].replace(/\+/g, " "));
}
var width = window.innerWidth,
	height = window.innerHeight,
	radius = 70,
	color = d3.scale.category20();

var force = d3.layout.force()
		.charge(-300)
		.linkDistance(100)
		.size([width, height]);

var svg = d3.select("body").append("svg")
		.attr("width", width)
		.attr("height", height);

var drawGraph = function(graph) {
	force
		.nodes(graph.nodes)
		.links(graph.links)
		.start();

	svg.append("svg:defs").selectAll("marker")
		.data(["arrow"])
		.enter()
		.append("marker")
			.attr("id", function(d) { return d; })
			.attr("viewBox", "0 -5 10 10")
			.attr("refX", 10)
			.attr("refY", 0)
			.attr("markerWidth", 10)
			.attr("markerHeight", 10)
			.attr("orient", "auto")
		.append("path")
			.style("stroke", function(d) { return "grey"; })
			.style("fill", function(d) { return "grey"; })
			.attr("d", "M0,-5L10,0L0,5");

	var links = svg.selectAll(".link")
		.data(graph.links)
		.enter()
			.append("svg:path")
			.style("fill", function(d) { return "none"; })
			.style("stroke", function(d) { return "grey"; })
			.attr("marker-end", function(d) { return "url(#arrow)"; });

	var gnodes = svg.selectAll('g.gnode')
		 .data(graph.nodes)
		 .enter()
		 .append('g')
		 .classed('gnode', true);
 
	var node = gnodes.append("path")
		.attr("d", d3.svg.symbol()
			.size(function(d) { return radius+d.size*radius; })
			.type(function(d) { return d.shape; })
		)
		.style("fill", function(d) { return color(d.group); })
		.style("stroke", function(d) { return d3.rgb(color(d.group)).darker(); })
		.call(force.drag);

	var labels = gnodes.append("text")
		.text(function(d) { return d.name; })
		.attr("x", function(d) { return 10 + d.size; })
		.attr("y", "3")
		.attr("font-family", "sans-serif")
		.attr("font-size","7pt")
		.attr("fill", function(d) { return d3.rgb(color(d.group)).darker(); });

	force.on("tick", function() {
		links.attr('d', linkRespectingRadius);
		gnodes.attr("transform", function(d) { 
				return 'translate(' + [d.x, d.y] + ')';
		});
	});
};

function linkRespectingRadius(d) {
	// Total difference in x and y from source to target
	diffX = d.target.x - d.source.x;
	diffY = d.target.y - d.source.y;

	// Length of path from center of source node to center of target node
	pathLength = Math.sqrt((diffX * diffX) + (diffY * diffY));
	radiusOfTarget=d.target.size+7
	// x and y distances from center to outside edge of target node
	offsetX = (diffX * radiusOfTarget) / pathLength;
	offsetY = (diffY * radiusOfTarget) / pathLength;

	return "M" + d.source.x + "," + d.source.y + "L" + (d.target.x - offsetX) + "," + (d.target.y - offsetY);
}

drawGraph(graph);

</script>
<p>Legend: Triangles are source code repositories, circles are pipelines, squares are pipeline templates. Lines indicate dependencies.</p>
<p>Developed from <a href="http://bl.ocks.org/mbostock">Mike Bostock's Force Directed Graph examples</a></p>